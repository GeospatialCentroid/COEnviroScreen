---
id: shiny
---


# EnviroScreen Shiny App overview

This document is meant to provide some description context to support active development and troubleshooting of the code base.


## Error and Troubleshooting

Troubleshooting a shinyapp can be a bit challenging at times. While developing this application, the most common source of error came from miss-matched variable names between the input dataset and parameters within the application. I speak about this quite directly throughout the document.
Aside from the naming issues, the three primary reactive elements (Map, histogram, and tables) interface with each other but not at the start of the application. This means that specific errors within those features will likely appear on deployment. Usually, the error message will point you to the correct element. If the app runs but fails once a specific request is provided, that's where to look.

If things are really bad, like when we tried the translation for the first time, follow the steps below.

1. Comment out all the content in the server function and make sure the UI looks like you expect it should.
2. Incrementally introduce a single server-side functionally at a time, making sure it works as expected before moving on.
  - this is a great way to understand the dependencies and input to the various reactive actions in the application.
3. once things work locally, test deployment to the server.


## Deployment

The `main` branch in the github repository reflects the currently deployed version of the application.

Any additional braches are there for specific development reasons and will be resolved into the main or deleted when appropriate.

Before deploying to the public URL
1. test the application locally.
  - take your time here. Run through tables, geographies, update the Map, test map layers.
  - errors with indicator names will only show when a specific indicator is selected.
2. Push version to test site on endpoint server.
  - This ensures your application will run on the shinyapps.io server
3. If it worked on the test site, push to the main server.
  - You be only slightly worried about crashing things at thing point because of the previous two steps.





## Inputs

- envoData : primary data generated by the data processing code base. Column names from this dataset are what defines the display of all information within the application. Change a column name without adjusting features in the application, and something, probably multiple reactive elements, will break.

- oil : Map visualization feature generated in the data processing code base.  
- coal : Map visualization feature generated in the data processing code base.
- rural : Map visualization feature generated in the data processing code base.
- descriptors : CSV containing indicator names, short descriptions, and all content displayed on the indicator descriptions table. Indicator names in this file must match those in the envoData dataset.
- justice40 : Map visualization feature generated in the data processing code base.
- di : Map visualization feature generated in the data processing code base.
- sm : Map visualization feature generated in the data processing code base.


## Reactive Objects
These features are what the users actively engage with to make changes to the application. Some are very obvious, things like buttons; others are more subtle, map clicks. Most of these features are defined in the UI, but some are actions defined within the widget (Map and tables).

**Defined in the UI**
- `updateMap` : Button that allows changes to geographic scale, indicator, and measure/percentile to occur. This button is here to prevent a lag of request. Specifically, with the census block level data, it takes a few seconds to update the map visualization.
- `Geom` : Used to define the geographic scale displayed on the Map, tables, and histograms. This object is used a lot for filtering datasets. Tables and histograms look to this object for changes.
- `Indicator` : Alters the layer displayed on the Map.
- `percentile` : Alters the layer displayed on the Map.
- `removeHighlight` : Clears the user-defined map element that can be added based on table selections.  
- `mymap` : The map object. This is the most engaged object within the application. There are two functions that influence it as well as proxy elements. It also ingests all input datasets in some way. The application was built around the Map, so it tends to be a bit more stable than the histograms/tables. That said, because it engages with all the data and most of the reactive elements, it is the best place to start the troubleshooting method.
- `indicatorDesc` : Block quote of short indicator descriptions
- `histEnviroScreen` : Histogram of the Enviroscreen Score. This feature is larger than other histograms. All histograms are defined with the same function, so issues should be evaluated from the function rather than the app.r file.
- `histExposure` : Historgram of environmental exposure
- `histEffect` :  Histogram of environmental effects
- `histClimate` : Histogram of Climate
- `histSocial` : Histogram of Social Economic
- `histDemo` : Histogram of Demographics
- `tableAll` : Constructs the data table from which specific tables are displayed.
- `tableSelect` : Filters the table data to visualize the information that the user has selected. Note that all but the Indicator Descriptions table are parsed from the same input dataset. Having two different input datasets under this call has created some real challenges in maintaining similar performance between the two features. Currently, the table works well for the enviroscreen data and not well for the reference material in the indicator description table. This is a compromise.
- `button_table` : a poorly named variable that creates a map object based on features selected in the table. Currently, selections are held across all tables. Selecting features on the Map also highlights the object on a table. The result of this is that there are  
- `downloadData` : Download the data held on all be the Indicator Description table. Data is limited to the currently selected geography.
- `downloadData2` : Download the data held in the Indicator Description table. This does not change with geography.

**inputs from base functionality**
- `mymap_shape_click` : Leaflet object that collects information about the user-selected map feature. This only applies to Indicator Layer. Selecting a DI community area does not affect the reactivity of the map elements. The select does two things automatically. One, histograms are redrawn to show the bin in which the selected feature was identified. Two, the table data is sorted so that the select object is at the top of the table. The table is sorted by the GEOID at that point. Same as alphabetically, except that some census tracts/block groups can appear above the selected GEOID. This measure that selecting a census tract from Adams county does not guarantee that ll census blocks from Adams county will be visible near the start of the table.
- `tableAll_rows_selected` : Datatable object that collects the rowid from the selected table. This is then used to gather the GEOID from the table. The GEOID is also used by the app to subset the envoData dataset and produce a new spatial object that is rendered on the Map.
- `mymap_shape_click$id` : The id parameter from the leaflet object is also the quick indexing of the GEOID. This allows the sorting of the datatable object.


## Reactive Elements

**tabset panels**
Not really a reactive element. Nothing about these table changes besides which feature is shown, but from the user perspective, they seem like on. These tabset panels play an important role in the application because they provide all the contextual information people need to understand what the application is talking about. That said, I don't like them. They are oddly finicky in weird ways. They also don't seem as adaptable as most other shiny elements. For example, I can create a in application link to the Map by defining a CSS class object for the fluid row that it rests in. I can't do this for the tabset panel element. It doesn't seem to respect the CSS structure in the same way the fluidrows do. I don't have a valid explanation. This rant is here to point caution to this useful but not very robust element of the application.

**Map Selection**
This series of buttons define the behavior or the Map, histograms, and table elements of the application. Changes to the Map require the use of the `update map` button. At the same time, changes to the histogram and tables are reactive to changes in the `geo scale` selection. Odd behavior, from the user perspective, can result when the geography displayed on the Map does not match the geography current selected under the `geo scale` drop down. Basically, the GEOID from map selections will never match the content in the histogram and tables, so there is a loss of functionality. The removed highlighted features from the Map works independently of other features. It's kinda out of place from a functional perspective but works well for user interaction.  

**Map**
This beauty is Map possible because of the `rmapshaper::ms_simplify()` function, which greatly reduces the complexity of input spatial datasets (up to an order of magnitude in overall file size) while maintaining topological relationships. We apply the function within the data processing code.
The Map is effect by four specific actions.
1. The Map is initially created with a predefined subset of the data. This allows for quick loading and allows the handling of all additional map layers.
2. As the user interacts with the `map selection` buttons, the Map is updated using a proxy call on the existing object. This allows the user to change what is presented as the Indicator map layer.
3. Adding highlighted features on the table to the Map all relies on a proxy call.
4. Removing highlighted features from the Map utilizes a proxy call.


**Histograms**
The histograms are all rendered about a single function. No proxy elements are used, meaning everything a new map feature is selected or a new geo scale is selected, all 6 histograms are regenerated. Labeling is handled with clauses within the function. The visualization effect for highlighting the bin required some duplication of code with the if/else statement. It should be obvious within the function; I just found that I ofter only edited one element rather than both when troubleshooting. The last note is that running locally, the histograms seem to be affected by the size of the plot display within your rstudio environment. This is very odd, but if you end up with a 'figure margin error', then it's worth increasing the display size of the plot viewer pane before looking at the code. I never encountered this error with deployment to shinyapps.io  


**Data Tables**
There is nothing too special about the data table themselves. They are indexed from a single datatable that is a subset of the currently selected geography. There are a lot of changes to make here if you end up changing indicator names. As noted above, the Indicator Description table breaks the mold of the other tables and does not react the same way as others. It is great to improve this at some point, but for now, I think it is a reasonable defect to maintain.


## Functions

Functions are used within the application for one of two reasons.

1. They represent a reusable code chunk that is deployed multiple times
2. They represent a container for an isolated code chuck so that lines of code can be removed from the app.r file  

My interest in utilizing function for contains has a cost when it comes to indicator name changes. You have to replace feature names within the app.r and functions. Still, the endless scrolling of hundreds of lines of code is bothersome, so we've got container functions.

`appPolyLine`

**description**: Adds a polyline feature to an existing map object
**inputs** :
 - Map: leaflet map object this
 - sf1 : spatial data representing the polyline *note*: polyline rather than polygon due to the visualization technique applied to these features.
 - group : layerId, used to turn the feature on and off in the Map
 - popup : Text description to include in the popup
**outputs** : returns a visualized polyline object that can appear on the Map.
**considerations**: Created to add the three community layers (oil, coal, rural). Mostly a container function.

---

`createMap`

**description**: This defines the initial map object. Lots of leaflet functions are coming in to make the Map.
**inputs**
- mapData : sf object used to define the indicator layer
- pal : vector of hex codes used for the legend of the indicator layer
- palMap :  leaflet palette object used to visualize the indicator layer  
- diPal :  leaflet palette object used to visualize the DI layer  
- oil : sf object for the oil community layer
- rural : sf object for the rural community layer
- coal : sf object for the coal community layer
- di : sf object for the di community layer
- justice40 : sf object for the justice40 layer
- storyMaps : sf object for the story maps layer
**outputs** : leaflet map object
**considerations**: Mostly a container function. Calling on other functions within. Keep care to ensure the group names remain consistent as they occur in multiple places within the function.

---

`defineLegend`

**description**: Assigns label values to legend based on the indicator name.
**inputs**  
- indicator : indicator name.
**outputs** : vector of character values to be used to label indicator layers within the legend  
**considerations**: If you change indicator names in the input datasets, you have to change them within this function as well.

---

`genPlots`

**description**: Comprehensive function for generating the histograms.
**inputs**  
- dataframe : envoData filtered to the geography of interest
- parameter : Component score to be visualized
- geometry : Character from geo scale drop-down, used to determine axis labels.
- geoid = NULL : value from user map click. Set to null to default. If a statement is built around this parameter, it determines if a single color is two-colored histograms are generated.
**outputs** : plotly object   
**considerations**: There are a lot of conditional statements in here as this is applied to 6 different indicators at three different geographies. Be aware of the if statement around the geiod parameter as there is a lot of duplicated code present there.


---

`genTable`

**description**: Largely a multi-part select function to produce the table the user wants.
**inputs**  
- tableData : envoData filtered to the geography of interest
- geoid : Value from the selection of a map feature. Used to order the table data
- colselected : user input selection of what table to view.  
**outputs** : datatable object    
**considerations**: This function does not include the Indicator Description table. Any changes to names in the input dataset will require alterations here.  

---

`getDI`

**description**: Container function to construct the DI community map layer .
**inputs**  : NA
**outputs** : SF object     
**considerations**: All this can be done within the data processing code base; consider moving it out of the application in the future.


---

`getStoryMaps`

**description**: Generate the story map sf object.
**inputs**  : NA
**outputs** : SF object     
**considerations**: We only use this story may data within the shiny app. Will need to update the function once we get more links.

----

`initialMapData`

**description**: Simply container function to simplify input dataset for intial map construction.
**inputs**  : SF object
**outputs** : SF object     
**considerations**: NA


## SCSS and inline HTML

Styling within the shiny application occurs in three different ways.

1.  Through the `bslib::bs_theme` function.
2. Through class definitions and  scss script
3. Through inline html/css

The base theme is set by the `bslib` function. Changing these parameters will directly alter the look of the application. That said, this library is mostly responsible for the look of the buttons.

Within the `bslib` funciton, a scss file is a reference as a source of additional rules. The `style.scss` file was generated incrementally to address specific visualization requests. Rules within the scss file are meant to override the generic theme set by the `bs_theme`. Rules were attempted to be made as specifically as possible, though there are some generic applications such as styling all `p()` calls.

Inline html/css was used as sparingly as possible, and over time it would be ideal for phasing it out entirely. For example, we utilize inline html to set the in-application relative link and maintain the proportion of the map element.

```r
# display map -------------------------------------------------------------
fluidRow(tags$style(type = "text/css", "#mymap {height: calc(100vh - 250px) !important;}"), #style = {"background-color:#4d3a7d;"},
         column(1),
         column(7, leafletOutput("mymap")),
         column(3, br(),br(),br(),br(),
                plotlyOutput("histEnviroScreen" ,height = "80%", width = "100%")),
         column(1),

),

```

Once you get the hand of utilizing a code editor within your browser, this can be pretty fun stuff to experiment with.

## Adaptations for Spanish

Ay Yai Yai, multilingual applications.

There is tremendous room for growth here. The initial development of the Spanish language version of enviroscreen took place in the last month of the project. The implementation of the application at release gets negative points for elegance and parsimony. Why all the trouble.

### Special Characters, sentence structure, and variable prepositions

**special characters**

Special characters have caused issues. Saving the files with encoding, "utf-8", has resolved the majority of these issues. The persistent problem is that a character string with special characters can not be passed through a function. The workaround for this was to dissolve all functions into the app.r file. As most functions were simply containers for saving space, this did not affect the functionality of the application. That said it does mean there are numerous redundant code chunks.

Special characters have also caused problems in the input RDS file. They were not being saved correctly. The workaround here was to utilize the `dplyr::select` function to rename all columns in the input dataset to ensure utf-8 formating.

The benefit of both these alterations is that all occurrences of input parameter names are present in the app.r script. This means adapting the code to account for changes in indicator names is significantly more straightforward as compared to the English implementation.

**Sentence structure**
Being a different language, Spanish utilizes a different sentence structure than English. This affected the position of intext formatting and hyperlinks. Once dealt with, this is not a major concern, but it is noted here because any additional translation efforts due require additional time for implementation.

**variable prepositions**
"Puntaje de Colorado EnviroScreen"
"Percentil del puntaje de Colorado EnviroScreen"
"Contaminación y carga climática"
"Percentil de contaminación y carga climática"

Sometimes it's del; sometimes it's de. Nothing wrong with either. The challenge came from the fact that the application constructs the percentile indicator names based on the input variable name alone. That is we don't store the percentile del puntaje de Coloroado Enviroscreen in a drop-down list. Instead, we store "Puntaje de Colorado EnviroScreen" and measure or percentile. Based on the selection, the indicator name is selected. This resulted in an additional clause statement. Not that big of a deal, but this is a potential problem others will need to address in the future.

```r
# indicator
       in1 <- input$Indicator
       # need to lower the first letter in the string but nothing else
       # grab first letter and set to lower
       t1 <- tolower(str_sub(in1, 1, 1))
       # subset out first letter
       t2 <- str_sub(in1, 2, nchar(in1))
       # construct new string
       indicator1 <- in1
       # sometimes it's del sometimes it de
       if(in1 %in% c("Puntaje de Colorado EnviroScreen"
                     ,"Indicador de descargas de aguas residuales"
                     ,"Indicador de salud mental"
                     ,"Porcentaje de discapacidades"
                     ,'Porcentaje que no completaron los estudios de secundaria'
                     ,"Porcentaje de aislamiento lingüístico"
                     ,"Porcentaje de bajos ingresos"
                     ,"Porcentaje de personas de color"
       )){
         indicator2 <- paste0("Percentil del ", t1,t2)
       }else{
         indicator2 <- paste0("Percentil de ", t1,t2)
       }

       if(input$Percentile == "Valor medido"){
         indicator <- indicator1
       }
       if(input$Percentile == "Rango percentil"){
         indicator <- indicator2
       }

```


### Spanish/English Overall

Translation work presents a unique set of challenges. The benefit of the process is that it forces you to reevaluate the structure and function of your application. The result in the case of EnviroScreen is two applications that take very different routes to get to the same place.


## Questions
carverd@colostate.edu
